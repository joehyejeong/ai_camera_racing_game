// Generated by CoffeeScript 1.7.1
(function () {
  var $, a, defaultControls, getWebGL, hasWebGL, init, s, u, _fn, _i, _len;

  $ = function (_) {
    return document.getElementById(_);
  };

  init = function (controlType, quality, hud, godmode) {
    var hexGL, progressbar;
    hexGL = new bkcore.hexgl.HexGL({
      document: document,
      width: window.innerWidth,
      height: window.innerHeight,
      container: $('main'),
      overlay: $('overlay'),
      gameover: $('step-5'),
      quality: quality,
      difficulty: 0,
      hud: hud === 1,
      controlType: controlType,
      godmode: godmode,
      track: 'Cityscape'
    });
    window.hexGL = hexGL;
    progressbar = $('progressbar');
    return hexGL.load({
      onLoad: function () {
        console.log('LOADED.');
        // Stop landing page reader if running, ShipControls will take over
        var stopReader = async function () {
          if (window.serialReader) {
            try {
              var releasePromise = window.serialReader.releaseLock();
              if (releasePromise && typeof releasePromise.then === 'function') {
                // Wait for release to complete
                await releasePromise.catch(function () { });
              }
            } catch (e) {
              // Ignore errors, may already be released
            }
            window.serialReader = null;
          }

          // Additional check: wait a bit if stream is still locked
          if (window.serialPort && window.serialPort.readable) {
            var attempts = 0;
            while (attempts < 20 && window.serialPort.readable.locked) {
              await new Promise(function (resolve) { setTimeout(resolve, 10); });
              attempts++;
            }
          }
        };

        // Wait for reader to be released, then start game
        stopReader().then(function () {
          hexGL.init();
          $('step-3').style.display = 'none';
          $('step-4').style.display = 'block';
          // ShipControls will automatically use global port if available
          return hexGL.start();
        }).catch(function (error) {
          console.error('Error stopping reader:', error);
          // Start anyway
          hexGL.init();
          $('step-3').style.display = 'none';
          $('step-4').style.display = 'block';
          return hexGL.start();
        });
      },
      onError: function (s) {
        return console.error("Error loading " + s + ".");
      },
      onProgress: function (p, t, n) {
        console.log("LOADED " + t + " : " + n + " ( " + p.loaded + " / " + p.total + " ).");
        return progressbar.style.width = "" + (p.loaded / p.total * 100) + "%";
      }
    });
  };

  u = bkcore.Utils.getURLParameter;

  // Only show CONTROL: AI CAMERA button, set defaults for others
  var defaultControls = 0;  // AI CAMERA
  var defaultQuality = 3;   // HIGH
  var defaultGodmode = 0;   // OFF

  s = [['controlType', ['AI CAMERA', 'TOUCH', 'LEAP MOTION CONTROLLER', 'GAMEPAD'], defaultControls, defaultControls, 'Controls: ']];

  _fn = function (a) {
    var e, f, _ref;
    a[3] = (_ref = u(a[0])) != null ? _ref : a[2];
    e = $("s-" + a[0]);
    (f = function () {
      return e.innerHTML = a[4] + a[1][a[3]];
    })();
    // controlType is fixed to AI CAMERA, no onclick handler
    if (a[0] !== 'controlType') {
      return e.onclick = function () {
        return f(a[3] = (a[3] + 1) % a[1].length);
      };
    }
  };
  for (_i = 0, _len = s.length; _i < _len; _i++) {
    a = s[_i];
    _fn(a);
  }

  // Serial protocol constants and classes (from ShipControls.js)
  var HEXGL_MESSAGE_HEAD_CODE = 0xFD;
  var HEXGL_MESSAGE_END_CODE = 0xED;

  var HexglMessageCommand = {
    KEYPOINT_BOX_DETECTION: 0,
    CLASSIFICATION: 1,
    DETECTION: 2
  };

  var HexglReceiveState = {
    WAIT_START: 0,
    HEAD: 1,
    DATA: 2,
    CRC: 3,
    END: 4
  };

  // HexglAiCamProtocol class (from ShipControls.js)
  var HexglAiCamProtocol = function () {
    this.state = HexglReceiveState.WAIT_START;
    this.currentMessage = null;
    this.receiveBuffer = [];
  };

  HexglAiCamProtocol.prototype.feedByte = function (byte) {
    switch (this.state) {
      case HexglReceiveState.WAIT_START:
        if (byte === HEXGL_MESSAGE_HEAD_CODE) {
          this.currentMessage = {
            head: { head: byte, cmd: 0, length: 0 },
            data: [],
            crc: 0,
            end: 0
          };
          this.receiveBuffer = [];
          this.state = HexglReceiveState.HEAD;
        }
        break;

      case HexglReceiveState.HEAD:
        this.receiveBuffer.push(byte);
        if (this.receiveBuffer.length === 3) {
          this.currentMessage.head.cmd = this.receiveBuffer[0];
          this.currentMessage.head.length = this.receiveBuffer[1] | (this.receiveBuffer[2] << 8);
          this.receiveBuffer = [];
          this.state = HexglReceiveState.DATA;
        }
        break;

      case HexglReceiveState.DATA:
        this.receiveBuffer.push(byte);
        if (this.receiveBuffer.length === this.currentMessage.head.length) {
          this.currentMessage.data = this.receiveBuffer.slice(0);
          this.receiveBuffer = [];
          this.state = HexglReceiveState.CRC;
        }
        break;

      case HexglReceiveState.CRC:
        this.receiveBuffer.push(byte);
        if (this.receiveBuffer.length === 4) {
          this.currentMessage.crc = this.receiveBuffer[0] |
            (this.receiveBuffer[1] << 8) |
            (this.receiveBuffer[2] << 16) |
            (this.receiveBuffer[3] << 24);
          this.receiveBuffer = [];
          this.state = HexglReceiveState.END;
        }
        break;

      case HexglReceiveState.END:
        if (byte === HEXGL_MESSAGE_END_CODE) {
          this.state = HexglReceiveState.WAIT_START;
          this.currentMessage.end = byte;
          return this.currentMessage;
        }
        break;
    }

    return null;
  };

  HexglAiCamProtocol.prototype.reset = function () {
    this.state = HexglReceiveState.WAIT_START;
    this.currentMessage = null;
    this.receiveBuffer = [];
  };

  // Web Serial connection handler - use global variable to persist across pages
  window.serialPort = window.serialPort || null;
  window.serialReader = window.serialReader || null;
  window.serialProtocol = window.serialProtocol || new HexglAiCamProtocol();

  var updateSerialButtonText = function () {
    var hudButton = $('s-hud');
    if (hudButton && window.serialPort && window.serialPort.readable) {
      hudButton.innerHTML = 'Web Serial: Connected';
    } else if (hudButton) {
      hudButton.innerHTML = 'Web Serial';
    }
  };

  // Handle parsed serial message (from ShipControls.js)
  var handleSerialMessage = function (msg) {
    if (!msg || !msg.head) {
      return;
    }

    // If game has started, use ShipControls for handling
    if (window.hexGL && window.hexGL.components && window.hexGL.components.shipControls) {
      var shipControls = window.hexGL.components.shipControls;

      // CLASSIFICATION message
      if (msg.head.cmd === HexglMessageCommand.CLASSIFICATION) {
        var type = msg.data && msg.data.length > 0 ? msg.data[0] : null;
        for (var i = 1; i < msg.head.length; i += 2) {
          var id = msg.data[i];
          var confidence = msg.data[i + 1];
          if (typeof id !== 'undefined') {
            // Log to ShipControls debug UI
            shipControls.logSerialParsedMessage({
              source: 'classification',
              type: type,
              id: id,
              confidence: confidence,
              action: shipControls.getSerialActionLabel(id)
            });
            // Execute game action
            shipControls.handleSerialAction(id, confidence);
          }
        }
      }
      // DETECTION message
      else if (msg.head.cmd === HexglMessageCommand.DETECTION) {
        var dtype = msg.data && msg.data.length > 0 ? msg.data[0] : null;
        for (var j = 1; j < msg.head.length; j += 6) {
          if (j + 5 >= msg.head.length) {
            break;
          }
          var did = msg.data[j];
          var dconfidence = msg.data[j + 5];
          if (typeof did !== 'undefined') {
            // Log to ShipControls debug UI
            shipControls.logSerialParsedMessage({
              source: 'detection',
              type: dtype,
              id: did,
              confidence: dconfidence,
              centroid: { x: msg.data[j + 1], y: msg.data[j + 2] },
              size: { w: msg.data[j + 3], h: msg.data[j + 4] },
              action: shipControls.getSerialActionLabel(did)
            });
            // Execute game action
            shipControls.handleSerialAction(did, dconfidence);
          }
        }
      }
    } else {
      // Game not started yet, just log to console
      if (msg.head.cmd === HexglMessageCommand.CLASSIFICATION) {
        var type = msg.data && msg.data.length > 0 ? msg.data[0] : null;
        for (var i = 1; i < msg.head.length; i += 2) {
          var id = msg.data[i];
          var confidence = msg.data[i + 1];
          if (typeof id !== 'undefined') {
            console.log('Serial Classification:', { type: type, id: id, confidence: confidence });
          }
        }
      } else if (msg.head.cmd === HexglMessageCommand.DETECTION) {
        var dtype = msg.data && msg.data.length > 0 ? msg.data[0] : null;
        for (var j = 1; j < msg.head.length; j += 6) {
          if (j + 5 >= msg.head.length) {
            break;
          }
          var did = msg.data[j];
          var dconfidence = msg.data[j + 5];
          if (typeof did !== 'undefined') {
            console.log('Serial Detection:', {
              type: dtype,
              id: did,
              confidence: dconfidence,
              centroid: { x: msg.data[j + 1], y: msg.data[j + 2] },
              size: { w: msg.data[j + 3], h: msg.data[j + 4] }
            });
          }
        }
      }
    }
  };

  // Start reading from serial port if already connected
  var startSerialReading = function () {
    if (window.serialPort && window.serialPort.readable && !window.serialReader) {
      try {
        // Reset protocol state
        window.serialProtocol.reset();
        window.serialReader = window.serialPort.readable.getReader();
        console.log('Serial reader recreated for game');

        var readLoop = function () {
          window.serialReader.read().then(function (_ref3) {
            var value = _ref3.value,
              done = _ref3.done;
            if (done) {
              if (window.serialReader) {
                try {
                  var releasePromise = window.serialReader.releaseLock();
                  if (releasePromise && typeof releasePromise.catch === 'function') {
                    releasePromise.catch(function () { });
                  }
                } catch (e) {
                  // Ignore errors
                }
                window.serialReader = null;
              }
              return;
            }
            if (value) {
              // Parse bytes using protocol (from ShipControls.js)
              // If game started, let ShipControls handle it (it will use its own reader)
              // Otherwise, handle here for landing page
              if (window.hexGL && window.hexGL.components && window.hexGL.components.shipControls) {
                // Game started, reader should be stopped, but if still running, stop it
                return;
              }
              for (var k = 0; k < value.length; k++) {
                var byte = value[k];
                // Log raw byte if ShipControls is available
                if (window.hexGL && window.hexGL.components && window.hexGL.components.shipControls) {
                  window.hexGL.components.shipControls.logSerialRawByte(byte);
                }
                var message = window.serialProtocol.feedByte(byte);
                if (message) {
                  handleSerialMessage(message);
                }
              }
            }
            if (window.serialReader) {
              readLoop();
            }
          }).catch(function (error) {
            // NetworkError usually means device was disconnected
            if (error.name === 'NetworkError' || (error.message && error.message.includes('device has been lost'))) {
              console.warn('Serial device disconnected:', error.message || error);
              if (window.serialReader) {
                try {
                  var releasePromise = window.serialReader.releaseLock();
                  if (releasePromise && typeof releasePromise.catch === 'function') {
                    releasePromise.catch(function () { });
                  }
                } catch (e) {
                  // Ignore errors
                }
                window.serialReader = null;
              }
              // Reset protocol on disconnect
              window.serialProtocol.reset();
              // Don't try to reconnect if device is lost
              return;
            }
            console.error('Read error:', error);
            if (window.serialReader) {
              try {
                var releasePromise = window.serialReader.releaseLock();
                if (releasePromise && typeof releasePromise.catch === 'function') {
                  releasePromise.catch(function () { });
                }
              } catch (e) {
                // Ignore errors
              }
              window.serialReader = null;
            }
            // Reset protocol on error
            window.serialProtocol.reset();
            // Try to reconnect if port is still open (only for non-fatal errors)
            if (window.serialPort && window.serialPort.readable) {
              try {
                window.serialProtocol.reset();
                window.serialReader = window.serialPort.readable.getReader();
                readLoop();
              } catch (e) {
                console.error('Failed to recreate reader:', e);
              }
            }
          });
        };

        readLoop();
      } catch (e) {
        console.error('Failed to create serial reader:', e);
      }
    }
  };

  // Make startSerialReading globally available
  window.startSerialReading = startSerialReading;

  // Update button text on page load if already connected
  updateSerialButtonText();

  $('s-hud').onclick = function () {
    if (!navigator.serial) {
      alert('Web Serial API is not supported in this browser. Please use Chrome, Edge, or Opera.');
      return;
    }

    if (window.serialPort && window.serialPort.readable) {
      // Already connected, close connection
      if (window.serialReader) {
        window.serialReader.releaseLock().catch(function () { });
        window.serialReader = null;
      }
      window.serialPort.close();
      window.serialPort = null;
      updateSerialButtonText();
      console.log('Serial port closed');
    } else {
      // Request port and connect
      navigator.serial.requestPort().then(function (port) {
        window.serialPort = port;
        // Open with default baud rate 9600
        return port.open({
          baudRate: 9600
        }).then(function () {
          updateSerialButtonText();
          console.log('Serial port opened successfully');
          // Reset protocol on new connection
          window.serialProtocol.reset();
          startSerialReading();
        }).catch(function (error) {
          console.error('Error opening serial port:', error);
          alert('Failed to open serial port: ' + error.message);
          window.serialPort = null;
          updateSerialButtonText();
        });
      }).catch(function (error) {
        if (error.name === 'NotFoundError') {
          console.log('No port selected');
        } else {
          console.error('Error with serial port:', error);
          alert('Failed to connect to serial port: ' + (error.message || error.toString()));
        }
      });
    }
  };

  $('step-2').onclick = function () {
    $('step-2').style.display = 'none';
    $('step-3').style.display = 'block';
    // hud parameter: default to 1 (ON) since we removed the toggle
    var defaultHud = 1;
    return init(s[0][3], defaultQuality, defaultHud, defaultGodmode);
  };

  $('step-5').onclick = function () {
    return window.location.reload();
  };

  // RANKING button handler
  $('s-ranking').onclick = function () {
    $('step-1').style.display = 'none';
    $('ranking').style.display = 'block';
    // Get best times and display
    var rankingList = $('ranking-list');
    if (rankingList) {
      var lines;
      if (window.hexGL) {
        lines = window.hexGL.buildBestTimesLines(true);
      } else {
        // HexGL not initialized yet, create temporary instance for best times
        var tempHexGL = new bkcore.hexgl.HexGL({
          document: document,
          track: 'Cityscape',
          difficulty: 0
        });
        lines = tempHexGL.buildBestTimesLines(true);
      }
      rankingList.textContent = lines.join('\n');
    }
  };

  $('ranking').onclick = function () {
    $('step-1').style.display = 'block';
    $('ranking').style.display = 'none';
  };

  // HELP button handler
  $('s-help').onclick = function () {
    $('step-1').style.display = 'none';
    $('help').style.display = 'block';
    var helpContainer = $('help-image-container');
    if (helpContainer) {
      helpContainer.style.backgroundImage = 'url(css/help-0.png)';
    }
  };

  $('help').onclick = function () {
    $('step-1').style.display = 'block';
    $('help').style.display = 'none';
  };

  hasWebGL = function () {
    var canvas, gl;
    gl = null;
    canvas = document.createElement('canvas');
    try {
      gl = canvas.getContext("webgl");
    } catch (_error) { }
    if (gl == null) {
      try {
        gl = canvas.getContext("experimental-webgl");
      } catch (_error) { }
    }
    return gl != null;
  };

  if (!hasWebGL()) {
    getWebGL = $('start');
    getWebGL.innerHTML = 'WebGL is not supported!';
    getWebGL.onclick = function () {
      return window.location.href = 'http://get.webgl.org/';
    };
  } else {
    $('start').onclick = function () {
      $('step-1').style.display = 'none';
      $('step-2').style.display = 'block';
      return $('step-2').style.backgroundImage = "url(css/help-" + s[0][3] + ".png)";
    };
  }

}).call(this);
